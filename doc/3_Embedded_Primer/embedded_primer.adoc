= Embedded Primer
:doctype: article
:imagesdir: imgs
:toc:

== Introduction
This lesson is a primer on working with embedded systems and the Zephyr RTOS.
Our goal is to complete the "Hello World" of embedded systems, blinking an LED from scratch.

=== What is an Embedded System?
Embedded systems are a small computer system that serves a specific purpose as part of a larger system.
Typically they will have limited resources such as memory and program size.
Some places you may see embedded systems are:

* Smartwatches
* IOT devices
* Car infotainment systems
* Keyboards and mice

Most embedded systems use a microcontroller which is a type of microprocessor that includes integrated memory and peripherals on a single chip.
We will be using the nRF52840 microcontroller in this course on the nRF52840 Development Kit provided by Nordic Semiconductor.

.The nRF52840 Processor Block Diagram. Source Nordic Semiconductor <<nordic-block>>
[]
image::block.nrf52840.svg[]

=== General Purpose Input Output (GPIO)
The General Purpose Input Output (GPIO) peripheral is one of the most common peripherals found on a microcontroller.
It provides a way to read and write digital signals to and from the physical pins on the microcontroller.
A pin controlled by the GPIO peripheral is referred to as a GPIO pin.
These pins can be used to read a button, turn on an LED, control enable lines for other chips, and much more.

To use one of the GPIO pins we first need to configure it.
Configuring the pin typically involves setting various registers (Registers are a logic circuit that store a value).
The GPIO pin configuration circuitry for the nRF52840 is shown below.

.nRF52840 GPIO Pin Configuration Block Diagram. Source Nordic Semiconductor <<nordic-gpio>>
[]
image::pin_block.svg[]

Each line coming into the configuration block represents the output of a bit from one of the control registers.
Each register is mapped to an address in the microcontroller allowing the developer to read and write to the register using pointers.

=== Zephyr RTOS
When working with embedded systems we generally have two options for writing software.

1. Write software that directly accesses the hardware registers to control the peripherals.
2. Use a hardware abstraction layer (HAL) to abstract the low level details of the hardware.

In general using a HAL is preferred as it makes the code easier to read, maintain, and port to other hardware.
Zephyr provides a HAL and a real time operating system (RTOS) for the nRF52840 and many other microcontrollers that makes working with this hardware easier.

==== Zephyr Project Layout
This is the layout of the EIE zephyr project

image::eie_project_layout.png[]
Below is a summary of each folder

* `.cache` is a folder generated by the build system. We can ignore this folder
* `.vscode` is a folder storing project specific configuration files for vscode.
* `app` is the directory containing all source code for the project.
This is the folder we will work with the most.
* `build` is where the compiled object files get generated.
* `doc` contains all the EIE documentation and lesson plan documents
* `scripts` contains helper scripts west uses to flash the board
* `zephyr` contains a single file called the west manifest.
When we ran `west update` in lesson 1 the west manifest was used to tell west what to update.

=== Embedded C

Often times when working with embedded systems C is the language of choice.
The following sections cover a few parts of the C language you may not be familiar with that are regularly needed in embedded systems development.

==== Integer data types

When writing to registers or preparing data to be sent over a serial connection we care about the size of the integers the data is written into.
In C the size of types like `char`, `short`, `long`, and `int` is implementation specific making them unsafe to use for many embedded applications.
We will often times use the integer types provided by the `stdint.h` library from the standard library instead.
These types include

* `int8_t`: An integer that is a fixed 8 bits
* `uint8_t`: An unsigned integer that is a fixed 8 bits
* `int16_t`: An integer that is a fixed 16 bits
* `uint16_t`: An unsigned integer that is a fixed 16 bits
* `int32_t`: An integer that is a fixed 32 bits
* `uint32_t`: An unsigned integer that is a fixed 32 bits

==== Hexadecimal and Binary Constants

In embedded programming it is often times more convenient to write some integer constants in binary or hexadecimal.
In C you can write a constant as hexadecimal by appending 0x in front of it or in binary by appending 0b in front of it.
For example all 3 constants below are the same value
[C]
----
0xAA // Hexadecimal
0b10101010 // Binary
170 // Decimal
----

==== Bitwise operators

In embedded programming we often times need to interact with individual bits in an integer value.
We can do this using bitwise operators.

* `&`: The bitwise AND operator. This operator takes two integers and performs a logical AND operation on each bit in the integers.
+
[C]
----
0b1100 & 0b1010 == 0b1000
----
The bitwise AND operator is often used to clear bits in a register or check if a bit is set.
+
[C]
----
0b1111 & 0b1101 == 0b1101 // Clear bit 1

if (0b1101 & 0b0100) { // Check if bit 2 is set
    // Bit 2 is set
}
----
* `|`: The bitwise OR operator. This operator takes two integers and performs a logical OR operation on each bit in the integers.
+
[C]
----
0b1100 | 0b1010 == 0b1110
----
The bitwise OR operator is often used to set bits in a register.
+
[C]
----
0b1100 | 0b0010 == 0b1110 // Set bit
----
* `^`: The bitwise XOR operator. This operator takes two integers and performs a logical XOR operation on each bit in the integers.
+
[C]
----
0b1100 ^ 0b1010 == 0b0110
----
The bitwise XOR operator is often used to toggle bits in a register.
+
[C]
----
0b1100 ^ 0b0100 == 0b1000 // Toggle bit
----
* `~`: The bitwise NOT operator. This operator takes a single integer and inverts all the bits in the integer.
+
[C]
----
~0b1100 == 0b0011
----
* `<<`: The left shift operator. This operator takes an integer and shifts all the bits in the integer to the left by a specified number of bits.
+
[C]
----
0b0001 << 2 == 0b0100
----
* `>>`: The right shift operator. This operator takes an integer and shifts all the bits
in the integer to the right by a specified number of bits.
+
[C]
----
0b0100 >> 2 == 0b0001
----

==== Hardware Abstraction via the Device Tree
The Zephyr project uses a data structure called a device tree to describe the microcontroller and the board it is on.
The microcontroller device tree definition file defines all the peripherals in the microcontroller and the addresses of the registers to control them.
The board device tree definition file describes how the microcontroller is connected to other components on the board such as LEDs, buttons, or sensors and what peripherals on the microcontroller they are connected to.
We won't cover too much about the device tree but more information can be found in the Zephyr documentation.
https://docs.zephyrproject.org/latest/build/dts/index.html

Additionally Nordic's DevAcadamy introductory course on the nRF Connect SDK covers the device tree in more detail in link:https://academy.nordicsemi.com/courses/nrf-connect-sdk-fundamentals/lessons/lesson-2-reading-buttons-and-controlling-leds/topic/devicetree/[Lesson 2].

== Lesson

=== Project Configuration

. Check out the `embedded_primer` branch:
+
----
git fetch upstream
git checkout upstream/embedded_primer
----
. VSCode tips: In addition to opening your git repository in your editor (see `code ./.vscode/eie.code-workspace` command), you can add directories like the `../modules` and `../zephyr` diretories. This will help vscode look into the HAL layer for your definition of includes. You can then save this as a workspace for future use. (see `.vscode/eie.code-workspace`).
. In the `app/` directory, create a new `src/` directory, as well as a new `main.c` file inside of `app/src/`. 
. KConfig is a configuration system originally developed for linux kernel development.
It allows developers to set configuration options for their application that are set at compile time.
In Zephyr these options are used to enable or disable features in the kernal and enable specific libraries.
+
For now we need to enable the GPIO library in our application so that we can use it to control the LED.
Open the `app/prj.conf` file in your editor.
We want to add a line to enable GPIO support in the application
+
image::prj_edits.png[]
Nordic's DevAcadamy course on nRF Connect SDK fundamentals covers more on kConfig including adding your own configuration options in link:https://academy.nordicsemi.com/courses/nrf-connect-sdk-fundamentals/lessons/lesson-3-elements-of-an-nrf-connect-sdk-application/topic/exercise-2/[Exercise 2 of Lesson 3].
. CMake is a meta-build tool; That is it doesn't compile source files on its own but rather tells other tools what to build.
In our case CMake pulls in the list of source file from the `CMakeLists.txt` file, the project configuration via the kConfig file `prj.conf` and the device tree files which describe the board and its peripherals.
It then generates files used by the ninja build system which uses the GNU toolchain to compile the application.
+
.The Zephyr build process. Source Nordic Semiconductor <<nordic-build-system>>
[]
image::https://docs-be.nordicsemi.com/bundle/ncs-latest/page/nrf/_images/ncs-toolchain.svg[]
+
Open the `app/CMakeLists.txt` file in your editor.
We need to add the `main.c` file to the `CMakeLists.txt` file so that CMake knows where our source code is.
In the future if we add more source files we will need to add them here as well.
Add the following line to the `CMakeLists.txt` file:
+
image::cmake_edits.png[]
. Add the files modified to the git staging area and commit the changes.
+
----
git add app/CMakeLists.txt app/prj.conf app/src/main.c
git commit -m "Setup project configuration"
----

=== Let's Blink an LED
. To start with we need to add some bare minimum code to our `main.c` file.
We need to include the Zephyr header files we are going to use and define the main function.
In the main function we will create an infinite while loop where our code will run.
This is a common pattern in embedded systems where there is no operating system to return to, so the application runs forever and main never returns.
+
image::minimum_main.png[]
At this point the application should build but won't do anything.
+
----
west build -b nrf52840dk/nrf52840 app
----
.. If the build is successful add the main.c file to the git staging area and commit the change. Use a commit message like "Add minimum main function".
. Now we need to define which pin is connected to the LED.
To do this first we need to get the LED pin configuration and fill our the zephyr GPIO device tree specification struct which is already defined for us in the Zephyr gpio.h file we included earlier.
+
image::dev_tree_gpio_struct.png[]
This struct defines the GPIO pin using the port the pin is on, the pin number and a flag field.
Most microcontrollers split their GPIO pins into multiple ports; The pins on each port typically are accessed through a single register.
The nRF52840 has 2 ports, port 0 and 1 each of which have a set of pins.
For our purposes, Zephyr abstracts this using the device tree.
The device tree configuration for the nRF52840DK specifies the port and pin number for each of the LEDs on the board.
We can then use the Zephyr `DT_ALIAS` and `GPIO_DT_SPEC_GET` macros to create the pin object for the LED we want to use.
+
image::pin_macros.png[]
. Next we need to initialize the GPIO pin and configure it to be an output pin.
First we need to check that the gpio struct we created is ready to use which we can do using the `gpio_is_ready_dt` function.
Then we can use the `gpio_pin_configure_dt` function which takes a pointer to the GPIO struct we made in the last step and a flag that will configure the pin mode.
Zephyr defines the following macros that we can use to set the pin mode:

* `GPIO_INPUT`: Configure the pin as an input. This will come up next week when we talk about buttons.
* `GPIO_OUTPUT`: Configure the pin as an output
* `GPIO_OUTPUT_ACTIVE`: Configure the pin as an output and set it to high
* `GPIO_OUTPUT_INACTIVE`: Configure the pin as an output and set it to low

+
In our case we will want to configure the LED as an output and set it high; this setting starts the LED off since the nRF52840DK uses active low LEDs.
In the end we should end up with code that looks like this that initializes the LED pin

+
image::pin_init.png[]
. Add your changes to the main.c file and commit them to git with a message like "Initialize LED pin".
. Now we need to make the LED blink.
There is a few zephyr APIs we can use to control the GPIO pin.
* `gpio_pin_set_dt`: This function takes a pointer to the GPIO struct and a value of 0 or 1 and sets the pin low or high respectively.
* `gpio_pin_toggle_dt`: This function takes a pointer to the GPIO struct and toggles the pin state from high to low or low to high.

+
In our case we will use the toggle function to blink the LED inside the while loop.

+
image::led_toggle.png[]
At this point you should be able to build the application and flash it to the board and the LED should blink.
----
west build -b nrf52840dk/nrf52840 app
west flash
----

=== Why is my LED not blinking?

. Let's look at the LED pin on an oscilloscope.
+
image::led_scope.png[]
We can see that the LED is blinking, but it is toggling every 500 nanoseconds!
This is far faster than we are able to see with our eyes.
. To fix this we need to add a delay between toggling the LED pin.
For this lesson we will use the zephyr `k_sleepms` function which puts the processor to sleep for a specified number of milliseconds.
In general in embedded systems we want the processor to be asleep as much as possible to save power.
When asleep the microcontroller puts the processor in a low power state while keeping peripherals like timers running to wake the processor up when it needs to do something.
After adding the delay the code should look like this and the LED should blink.
+
image::complete_main.png[]
. Now we can build and flash the application to the board again and the LED should blink once per second.
+
----
west build -b nrf52840dk/nrf52840 app
west flash
----
. Add your changes to the main.c file and commit them to git with a message like "Make LED blink".

== Exercise

Now that we have gotten one LED to blink on your own try the following:

* Make the other 3 LEDs blink.
* Make one LED blink twice as fast as the others.
* Make the LEDs blink in a sequence. (Example have the 4 LEDs turn on one at a time in a loop)

Create a separate commit for each part of the exercise you complete. When you are done push your changes to your copy of the repository on GitHub.
----
git push origin embedded_primer
----




[bibliography]
== References

* [[[nordic-block, 1]]] Nordic Semiconductor. _Block Diagram._ [Online]. Available: https://docs.nordicsemi.com/bundle/ps_nrf52840/page/blockdiagram.html
* [[[nordic-gpio, 2]]] Nordic Semiconductor. _GPIO - General purpose input/output._ [Online]. Available: https://docs.nordicsemi.com/bundle/ps_nrf52840/page/gpio.html
* [[[nordic-build-system, 3]]] Nordic Semiconductor. _Build and Configuration System._ [Online]. Available: https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/app_dev/config_and_build/config_and_build_system.html
