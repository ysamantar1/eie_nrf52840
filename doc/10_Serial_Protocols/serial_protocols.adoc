= Serial Protocols
:doctype: article
:imagesdir: imgs
:toc:
:xrefstyle: short
:source-highlighter: highlight.js
:stem: latexmath

== Introduction

In todays lesson we will be using various serial protocols to talk to a LCD shield for the nRF52840 dev kit.

=== What is serial communication

Serial communication is a way for multiple devices to communicate where data is exchanged one bit at a time.
Serial communication is often contrasted with parallel communication where all the a data is exchanged in chunks over multiple data lines.

.Serial vs parallel communication <<wiki_serial>>
[]
image::Serial_and_Parallel_Data_Transmission.svg[]

Serial communication gives us the advantage that it normally uses less data pins on a microcontroller compared to a parallel connection.

Using a serial bus we can connect our microcontroller to external sensors, DACs, ADCs, memory, and more expanding what we can do with it.
We will briefly cover 3 serial protocols that almost every modern microcontroller has dedicated hardware to support.

=== Serial Peripheral Interface (SPI)

The serial peripheral interface or SPI is a defacto standard serial communication protocol used for short range communication, typically between ICs on a single board.
SPI is full duplex, meaning data can be sent and received simultaneously, and synchronous, meaning communication is controlled by a clock.

SPI uses a master-slave topology where a master or controller device controls communication with one or more slave or peripheral devices using the SPI control lines.
SPI has 2 control lines, chip select (often times abreviated as CS) and clock.
The controller will have one chip select line per peripheral device and a shared clock and data bus for all peripherals.
If a controller wishes to talk to a peripheral it will pull the corresponding peripherals chip select line low then start the clock.
On each clock cycle data will be written/read from the SPI data bus by the controller and peripheral.
The SPI data bus has 2 data lines:

* Master Out Slave In (MOSI), sends data from the controller to the peripheral
* Master In Slave Out (MISO), sends data from the peripheral to the controller

If the application only needs to send data in one direction the other line can be excluded.

.SPI timing diagram: Shows how the various lines are used for SPI communication <<maker_spi>>
image::spi_timing.png[]

The diagram below shows how multiple peripherals can be connected on a single SPI bus

.SPI multiple peripheral single controller <<wiki_spi>>
image::SPI_three_slaves.svg[]

==== SPI Modes

There are 4 SPI modes dependent on the clock phase (CPHA) and clock polarity (CPOL)

[cols="1, 1, 1, 5"]
|===
|Mode | CPOL | CPHA | Effect
|0 | 0 | 0 | Clock is low when SPI is not active, data is read on rising edge
|1 | 0 | 1 | Clock is high when SPI is not active, data is read on rising edge
|2 | 1 | 0 | Clock is low when SPI is not active, data is read on falling edge
|3 | 1 | 1 | Clock is high when SPI is not active, data is read on falling edge
|===


=== Inter-Integrated Circuit (I2C)

Inter-integrated circuit is another serial communication protocol used for short range communication, typically between ICs  on a single board.
I2C is half duplex, meaning data can only be sent one direction at a time, and synchronous.

I2C also uses a master-slave topology. 
Unlike SPI, I2C only uses 2 lines

* Serial Data
* Clock

=== Other serial protocols

Below is a not exhaustive list of other serial protocols.

* *Universal Serial Bus (USB)*: USB is probably the serial protocol everyone is most familiar with as we use it for everything.
* *Ethernet*: Used networked communication between computers
* *HDMI*: Used for connections to displays like computer monitors and TVs
* *Control Area Network (CANBUS)*: Commonly used in automotive applications for communication between electronic control units
* *Morse Code*: Historical communication system used for the telegraph.
* *Serial AT Attachment (SATA)*: Used for connection to hard drives in computers
* *Peripheral Component Interconnect Express (PCIe)*: Used for high speed connections to expansion cards in computers like graphics cards, SSDs, and more.

== Lesson
This lesson will focus on enabling SPI and I2C to communicate with the LCD and touch controller respectively on the Adafruit 2.8" TFT Touch Shield V2.
A simplified schematic only showing the data connections between the nRF52840 and the components on the shield we can communicate with is shown below.

[[fig_schematic]]
.A simplified schematic showing the logical connections between the nRF52840 and the shield.
image::schematic.svg[]

This particular shield uses the FocalTech FT6206 touch controller (U3 on the schematic) connected via I2C, the ILITEK ILI9341 LCD driver over SPI (U2 on the schematic), and provides a micro SD card slot also connected over SPI (J1 on the schematic).
In this lesson we will focus on the touch controller and LCD driver.
The remainder of this lesson is split into 2 parts; one for SPI and one for I2C.
Each section can be completed independently.

The full schematic for the shield is available from adafruit<<shield_schematic>>.

=== Enabling SPI

We will be using SPI to talk to the LCD driver.

==== Hardware Configuration

Before we start writing software we need to figure out how to talk to the LCD driver.
To do this we will reference the datasheet which can be found online at https://cdn-shop.adafruit.com/datasheets/ILI9341.pdf <<ILI9341>>.
Throughout this lesson various datasheets will be referenced, however this is not a complete guide on how to read the datasheet.
In section 7 of the data sheet it covers the various interfaces that can be used to connect to a MCU.
In total there is 12 different interfaces we can use

* 8 Bit 8080-I MCU Bus Interface
* 9 Bit 8080-I MCU Bus Interface
* 16 Bit 8080-I MCU Bus Interface
* 18 Bit 8080-I MCU Bus Interface
* 8 Bit 8080-II MCU Bus Interface
* 9 Bit 8080-II MCU Bus Interface
* 16 Bit 8080-II MCU Bus Interface
* 18 Bit 8080-II MCU Bus Interface
* 3-Wire 9 Bit data serial interface I
* 4-Wire 8 Bit data serial interface I
* 3-Wire 9 Bit data serial interface II
* 4-Wire 8 Bit data serial interface II

We need to figure out which interface we can use.
Looking at section 7.1.1 of the datasheet a table is provided mapping the IM[3:0] pins on the driver to the interfaces.
This table is copied below for convenience.

.The interface selection table from the datasheet<<ILI9341>>
[]
image::interface_select_table.png[]

Consulting back to the schematic in <<fig_schematic>> we can see the IM[3:0] is set to `1110` on the shield.
As such we will be using the 4-Wire 8 Bit data serial interface II.

Referring to section 7.1.8 to sections 7.1.10 of the data sheet we can find everything we need to implement the basics needed to talk to the LCD.
The 4 line serial interface II in reality consists of 5 lines

* SCL
* SDI
* SDO
* CS
* D/CX

The first 4 lines are the lines we expect for SPI with the data command select line used to tell the LCD driver if we are sending a command or data.
As we can see in the schematic these lines are all connected to the nRF52840 allowing us to use this bus. 
The data sheet also mentions that data is read off the SDI line on the rising edge of the clock and that data is shifted out on the falling out of the clock. 
This implies we are using SPI mode 0.

==== Enabling Zephyr to talk over SPI

To talk over SPI with zephyr first we have to enable SPI in the KConfig file. 
Open the app/prj.conf file and add the following line to enable SPI.

[]
image::prj_edits.png[]

Next we need to tell zephyr which pins we are using on the board to communicate with the LCD driver.
To do this we will modify the device tree board overlay for the nRF52840dk. 
Open the app/boards/nrf52840dk_nrf52840.overlay file in your project and add the following sections.

[]
image::board_config.png[]

We are doing 2 things in this file.
First we are for convinience defining that pin 11 on GPIO port 1 is being called the dcx_gpios which will be used for the data/command select.
Second we are telling the board that that pin 12 on GPIO port 1 will be used as the CS for the arduino spi port.
As the nRF52840dk has the arduino compatible header files the arduino communication ports and headers are all pre-defined by the board device tree files.

At this point we can open the main.c file and add the necessary header files and configure the GPIO pins.
[]
image::main_c_gpio_configured.png[]
While the D/C select line was configured similarly to how we have configured GPIO in the past for LEDs or buttons, the CS uses a special data structure. 
For now we are setting the delay to 0, but this will be addressed later.

==== Configuring SPI

At this point we will be configuring the SPI peripheral on the nRF52840. 
Zephyr uses an internally defined struct to configure the SPI peripheral the definition of which is given below for convenience.
[C]
----
struct spi_config {
	/** @brief Bus frequency in Hertz. */
	uint32_t frequency;
	/**
	 * @brief Operation flags.
	 *
	 * It is a bit field with the following parts:
	 *
	 * - 0:      Master or slave.
	 * - 1..3:   Clock polarity, phase and loop mode.
	 * - 4:      LSB or MSB first.
	 * - 5..10:  Size of a data frame (word) in bits.
	 * - 11:     Full/half duplex.
	 * - 12:     Hold on the CS line if possible.
	 * - 13:     Keep resource locked for the caller.
	 * - 14:     Active high CS logic.
	 * - 15:     Motorola or TI frame format (optional).
	 *
	 * If @kconfig{CONFIG_SPI_EXTENDED_MODES} is enabled:
	 *
	 * - 16..17: MISO lines (Single/Dual/Quad/Octal).
	 * - 18..31: Reserved for future use.
	 */
	spi_operation_t operation;
	/** @brief Slave number from 0 to host controller slave limit. */
	uint16_t slave;
	/**
	 * @brief GPIO chip-select line (optional, must be initialized to zero
	 * if not used).
	 */
	struct spi_cs_control cs;
};
----
Let's look at these fields one by one.

Starting with frequency, this is the speed of the clock. 
Referring back to the LCD controller datasheet in section 18.3.4 we get a timing diagram giving us the minimum timing for the SPI bus. 
This diagram is copied below for convenience.

.SPI Timing diagram <<ILI9341>>
image::SPI_timing.png[]

In this case for clock frequency we need to look at the stem:[t_{wc}] and stem:[t_{rc}]. 
These refer to the minimum clock period for a write and read respectively. 
As we want just one time to select a frequency we will use the larger stem:[t_{rc}] of 150 ns.
Converting this to frequency we get a max clock frequency of 6.6 MHz, meaning we can chose any frequency slower.
For convenience we will set our clock frequency to 1 MHz or 1 000 000 Hz.

Additionally from the timing diagram we can use the stem:[t_{css}] and stem:[t_{csh}] timings to select the chip select delay.
These times refer to the minimum time the chip select must be low before data is sent and the minimum time the chip select must be held after a packet is finished being sent.
Both times are 40 ns, however the chip select delay is set in us so we will set the delay to 1 us.

Next we will set the operation field.
This field is a bit field that controls the SPI operation.
As a summary from previous sections

* The nRF52840 is the SPI master
* We are using SPI mode 0
* We are sending 8 byte packets 
* The data is being sent out MSB first

From this we can construct the bitfield.

The slave number can be set to 0.

Finally the chip select will be set to the chip select control struct previously made.
Putting this all together the final config looks like this.
[]
image::spi_config.png[]

Finally before we can talk to the LCD we will create a zephyr device struct which will allow us to access the SPI peripheral in the microcontroller.
In main we will check if the device is ready before use.

==== Talking to the LCD

Before we start sending data to the LCD we will create a helper function to send LCD commands.
[]
image::lcd_cmd.png[]
This function takes in a 1 byte command, and an optional pointer to data to send with the command.
First we put the command into the SPI buffer structures that zephyr uses to allow you to send multiple pieces of data at once.
Then we set the D/C select pin high to signal to the LCD we are about to send a command and send the command over SPI.
Next if data was passed in we can set the D/C select low to signal we are sending data and send the data.
Remember to also define your function prototype.

Finally we can start sending commands to the LCD. 
Looking at section 8 of the datasheet all the commands are listed, however we only need a small subset of them which for ease of use we will define as given below
[C]
----
#define CMD_SOFTWARE_RESET 0x01
#define CMD_SLEEP_OUT 0x11
#define CMD_DISPLAY_ON 0x29
#define CMD_COLUMN_ADDRESS_SET 0x2A
#define CMD_ROW_ADDRESS_SET 0x2B
#define CMD_MEMORY_WRITE 0x2C
----
We can use the first free commands to setup the LCD. 
None of these commands take data.
[]
image::lcd_setup.png[]

Next we can start writing data to LCD data buffer to draw on the screen.
This uses 3 commands: set column address, set row address and memory write.
Set column address takes in a start column from 0 to 319 (`0x139`) in 2 bytes and a end column with the same format.
Set row similarly takes a start row and end row in the range 0 to 239 (`0xEF`).
Memory write takes in multiples of 3 bytes giving the colour each pixel will be.
Starting from the top left corner of area specified with the set column and row address memory write can write multiple pixels at once left to write, top to bottom. 
The LCD does not use a full 8 bits for each colour.
Instead it uses a 18 bit colour system which the diagram below shows the packing in a SPI packet.

.18 bit colour mapping for SPI<<ILI9341>>
image::spi_color.png[]

The below code creates a 10 by 10 pixel red square roughly in the centre of the screen for example.
[]
image::lcd_draw_square.png[]

An example of the square is shown below
[]
image::red_square.jpg[width=50%]

We can also use an oscilloscope or logic analyser to view and decode the spi traces. 
For example below is showing when the column command and data is sent. 
The traces from top to bottom are the CS, MOSI, MISO, and CLK.
At the bottom we can see the scope is decoding the SPI messages, however these are truncated due to the level of zoom.
[]
image::SPI_SCOPE.png[]

For more information on these commands refer to sections 8.2.20 to 8.2.22 of the datasheet.


=== Enabling I2C

We will now look at how I2C can be used to enable the touch controller.

To start with like with every new feature in zephyr we have worked with we need to enable the corresponding config option in the KConfig file.
[]
image::i2c_config.png[]

Similarly to when we looked at SPI we will need the datasheet for the FT6206 touch controller.
The datasheet can be found here: https://cdn-shop.adafruit.com/datasheets/FT6x06%20Datasheet_V0.1_Preliminary_20120723.pdf <<FT6x06>>.

Looking through the datasheet we can see the FT6x06 provides a 

* I2C bus 
* interrupt signal to inform the host processor that there is touch data
* A reset line

Looking at the schematic in <<fig_schematic>> we can see that only the I2C bus is connected and thus we can ignore the interrupt and reset line.
In section 2.4 of the data sheet it tells us that the touch controller is always acting as the I2C slave, and that the I2C bus can support a clock frequency between 10 and 400 kHz<<FT6x06>>.
Missing from the datasheet for the touch controller is the I2C address. 
Looking through sample code for the FT6206 provided by Adafruit, we can find that the address is `0x38` or 56.

At this point we can start to add to our main.c file to turn on the I2C peripheral.
We will need to include the relevant header files, access the I2C peripheral from the device tree and create a associated device. 
Then in main we can check if the device is ready to use and configure the I2C bus.
Zephyr provides the i2c_configure API we can use to configure the I2C device. 
It takes in a device pointer and a config bitfield.
For the bitfield we will set the speed and I2C mode.
Based on the datasheet we will set the I2C mode to be a master or `I2C_MODE_CONTROLLER` and the speed to between 10 kHz and 400 kHz.
Zephyr provides pre-defined speeds for 100 kHz and 400 kHz as `I2C_SPEED_STANDARD` and `I2C_SPEED_FAST`.
In the example below `I2C_SPEED_FAST` is used, however either speed will work. 
[]
image::i2c_main_config.png[]

Next we can start actually reading and writing data to and from the touch controller.
Looking through the datasheet you may notice it doesn't actually document what data is sent over the I2C bus.
FocalTech chose to put the communication definitions in a separate application note available here:
https://cdn-shop.adafruit.com/datasheets/FT6x06_AN_public_ver0.1.3.pdf
Section 1.1 documents how data is read and written to the touch controller.
To read data a message is first written to the touch controller containing the register address we wish to read from.
Then a second message is started which reads the data back from that address<<FT6X06AN>>.
Section 3 of the application note then documents the various registers that can be read or written from and the data that is sent back or read.
For a simple driver to read the position of a touch we will need the `TD_STATUS`, `P1_XH`, `P1_XL`, `P1_YH`, and `P1_YL` registers. 
We can define constants to access them and some of the other data we will need more easily
[C]
----
#define SLEEP_MS 100
#define ADDR 0x38
#define TD_STATUS 0x02
#define P1_XH 0x03
#define P1_XL 0x04
#define P1_YH 0x05
#define P1_YL 0x06

#define TOUCH_EVENT_MASK 0xC0
#define TOUCH_EVENT_SHIFT 6

#define TOUCH_POS_MSB_MASK 0x0F

typedef enum {
  TOUCH_EVENT_PRESS_DOWN = 0b00u,
  TOUCH_EVENT_LIFT_UP = 0b01u,
  TOUCH_EVENT_CONTACT = 0b10u,
  TOUCH_EVENT_NO_EVENT = 0b11u
} touch_event_t;
----
Next we can write a simple function to send a command and recieve a response using the zephyr `i2c_transmit` API.
This API takes in the I2C device, an array of messages to be sent/received, the number of messages and the address of the device being talked to.
We will define the message array with 2 messages. 
The first message will be a message we write containing the register we want to read from.
The second message we will read from the bus into the response.
[]
image::i2c_helper.png[]

We can use this helper function to read touch events from the screen in our main loop.
[]
image::i2c_main_loop.png[]

Using an oscilloscope we can look at the I2C lines and see this working as expected
[]
image::I2C_SCOPE.PNG[]
In this case the top trace is the SDA line and the bottom trace is the SCL line.
We can also see at the bottom the scope is decoding the packet and we are first writing to the address `0x38` the data `0x04` corresponding to the `P1_XL` register then we read data back from address `0x38`, which in this case is `0x98` corresponding to part of the LSB of the x position.

== Exercise

* Combine the touch and LCD drivers we have written. 
  Have the LCD draw a shape at the location you touch.
* Create a gradient effect on the LCD over the whole screen.
* In the lesson we exclusively wrote data to the LCD driver and read data from the touch controller.
  Using the datasheets for both components find a data field you can read from the LCD driver and write to the touch controller.

[bibliography]
== References

* [[[shield_schematic, 1]]] adafruit. _Adafruit 2.8" TFT Touch Shield v2 - Capacitive Schematic._ [Online] Available: https://cdn-learn.adafruit.com/assets/assets/000/027/040/original/adafruit_products_cap_touch28_tft.png
* [[[ILI9341, 2]]] ILITEK. _ILI9341 a-SI TFT LCD Single Chip Driver 240RGBx320 Resolution and 262K color Specification._ [Online] Available: https://cdn-shop.adafruit.com/datasheets/ILI9341.pdf
* [[[FT6x06, 3]]] FocalTech. _FT6x06 Self-Capacitive Touch Panel Controller._ [Online] Available: https://cdn-shop.adafruit.com/datasheets/FT6x06%20Datasheet_V0.1_Preliminary_20120723.pdf
* [[[AdafruitFT6206, 4]]] Adafruit, _Adafruit_FT6206 Library._ [Online] Available https://github.com/adafruit/Adafruit_FT6206_Library
* [[[FT6X06AN, 5]]] FocalTech. _Application Note for FT6x06 CTPM._ [Online] Available: https://cdn-shop.adafruit.com/datasheets/FT6x06_AN_public_ver0.1.3.pdf
* [[[wiki_serial, 6]]] https://en.wikipedia.org/wiki/Serial_communication
* [[[wiki_spi, 7]]] https://en.wikipedia.org/wiki/Serial_Peripheral_Interface
* [[[maker_spi, 8]]] https://maker.pro/custom/tutorial/an-introduction-to-spi-communications-protocol
